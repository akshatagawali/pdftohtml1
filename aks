import base64
import html
import traceback
from io import BytesIO
from spire.pdf.common import *
from spire.pdf import *
from typing import Any, Dict, List, Tuple
import os
from PIL import Image

# Updated HTML template
html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PDF to HTML Conversion</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
        }}
        .page {{
            margin-bottom: 40px;
            border: 1px solid #ccc;
            padding: 20px;
            background-color: #f9f9f9;
            position: relative;
        }}
        .text-line {{
            margin-bottom: 10px;
            line-height: 1.6;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }}
        table, th, td {{
            border: 1px solid #ddd;
        }}
        th, td {{
            padding: 8px;
            text-align: left;
        }}
        img {{
            max-width: 100%;
            height: auto;
            display: block;
            margin-bottom: 20px;
        }}
        h2 {{
            margin-bottom: 20px;
        }}
        h3 {{
            margin-bottom: 10px;
        }}
        .content-container {{
            position: relative;
        }}
    </style>
</head>
<body>
    {content}
</body>
</html>
"""

def _safe_escape(content: Any) -> str:
    try:
        return html.escape(str(content).strip()) if content is not None else ""
    except Exception as e:
        print(f"Error escaping content: {e}")
        return f"[Error processing content] {str(content)}"


def extract_images(pdf_path: str) -> List[List[Dict[str, Any]]]:
    output_folder = "extracted_images"
    images_per_page = []
    try:
        doc = PdfDocument()
        doc.LoadFromFile(pdf_path)  # Load PDF
        imageHelper = PdfImageHelper()
        
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        for i in range(doc.Pages.Count):
            page = doc.Pages.get_Item(i)
            imageInfos = imageHelper.GetImagesInfo(page)
            images = []
            
            for j, imageInfo in enumerate(imageInfos):
                image_stream = imageInfo.Image  # This is a Stream object
                
                # Convert the Spire.PDF Stream to a BytesIO object
                image_bytes = BytesIO(image_stream.ToArray())  

                # Open the image using PIL (Pillow)
                pil_image = Image.open(image_bytes)

                # Save image to file
                image_path = os.path.join(output_folder, f"page_{i+1}image{j+1}.png")
                pil_image.save(image_path, format="PNG")

                # Convert image to base64
                with open(image_path, "rb") as img_file:
                    image_base64 = base64.b64encode(img_file.read()).decode("utf-8")

                # Get the bounding box of the image
                bounding_box = imageInfo.Bounds  # This is a RectangleF object
                bbox = {
                    "x": bounding_box.X,
                    "y": bounding_box.Y,
                    "width": bounding_box.Width,
                    "height": bounding_box.Height
                }

                # Append image and bounding box information
                images.append({
                    "image": f"data:image/png;base64,{image_base64}",
                    "bounding_box": bbox
                })

            images_per_page.append(images)

        doc.Dispose()  # Close document
        return images_per_page

    except Exception as e:
        print(f"Error extracting images: {e}")
        return []


def extract_content(pdf_path: str) -> List[Dict[str, Any]]:
    try:
        with open(pdf_path, "rb") as pdf_file:
            poller = client.begin_analyze_document("prebuilt-layout", document=pdf_file)
            result = poller.result()

        pages_content = [{"text": [], "tables": [], "images": []} for _ in range(len(result.pages))]
        for page_number, page in enumerate(result.pages):
            blocked_areas = []
            for table in result.tables:
                if table.bounding_regions:
                    blocked_areas.append((
                        table.bounding_regions[0].polygon[0].x,
                        table.bounding_regions[0].polygon[0].y,
                        abs(table.bounding_regions[0].polygon[2].x - table.bounding_regions[0].polygon[0].x),
                        abs(table.bounding_regions[0].polygon[2].y - table.bounding_regions[0].polygon[0].y)
                    ))
            
            text_lines = []
            for line in page.lines:
                line_poly = line.polygon
                if line_poly and len(line_poly) >= 3:
                    line_x = line_poly[0].x
                    line_y = line_poly[0].y
                    line_width = abs(line_poly[2].x - line_poly[0].x)
                    line_height = abs(line_poly[2].y - line_poly[0].y)
                    is_blocked = any(
                        _lines_overlap(line_x, line_y, line_width, line_height, blocked_area)
                        for blocked_area in blocked_areas
                    )
                    if not is_blocked:
                        text_lines.append({
                            "content": line.content,
                            "bounding_box": {
                                "x": line_x,
                                "y": line_y,
                                "width": line_width,
                                "height": line_height
                            }
                        })
            
            pages_content[page_number]["text"] = text_lines

            for table in result.tables:
                unique_columns = len(set(cell.column_index for cell in table.cells))
                table_data = []
                for row_index in range(max(cell.row_index for cell in table.cells) + 1):
                    row_data = [""] * unique_columns
                    for cell in table.cells:
                        if cell.row_index == row_index:
                            row_data[cell.column_index] = cell.content or ""
                    table_data.append(row_data)
                
                # Add table bounding box
                if table.bounding_regions:
                    table_bbox = {
                        "x": table.bounding_regions[0].polygon[0].x,
                        "y": table.bounding_regions[0].polygon[0].y,
                        "width": abs(table.bounding_regions[0].polygon[2].x - table.bounding_regions[0].polygon[0].x),
                        "height": abs(table.bounding_regions[0].polygon[2].y - table.bounding_regions[0].polygon[0].y)
                    }
                    pages_content[table.bounding_regions[0].page_number - 1]["tables"].append({
                        "data": table_data,
                        "bounding_box": table_bbox
                    })

            # Extract images separately
            images_per_page = extract_images(pdf_path)
            for page_number, images in enumerate(images_per_page):
                pages_content[page_number]["images"].extend(images)
            return pages_content

    except Exception as e:
        print(f"Error extracting PDF content: {e}")
        traceback.print_exc()
        return []


def _lines_overlap(line_x: float, line_y: float, line_width: float, line_height: float, blocked_area: Tuple[float, float, float, float]) -> bool:
    try:
        # Unpack blocked area
        bx, by, bw, bh = blocked_area
        
        # Check for overlap
        return not (
            line_x + line_width < bx or  # line is left of blocked area
            line_x > bx + bw or  # line is right of blocked area
            line_y + line_height < by or  # line is above blocked area
            line_y > by + bh     # line is below blocked area
        )
    except Exception as e:
        print(f"Error checking line overlap: {e}")
        return False


def convert_to_html(pages_content: List[Dict[str, Any]], output_path: str):
    """Convert extracted content to HTML"""
    try:
        html_content = ""

        for page_index, page in enumerate(pages_content, 1):
            print(page)
            page_html = f'<div class="page" id="page-{page_index}">\n'
            page_html += f'<h2>Page {page_index}</h2>\n'
            page_html += '<div class="content-container">\n'

            # Add text lines
            for text_line in page.get("text", []):
                page_html += f'<div class="text-line">{_safe_escape(text_line["content"])}</div>\n'

            # Add tables
            for table_index, table in enumerate(page.get("tables", []), 1):
                if not table:
                    continue
                page_html += f'<h3>Table {table_index}</h3>\n<table>\n'
                for row in table.get("data", []):
                    page_html += "<tr>\n"
                    for cell in row:
                        page_html += f"<td>{_safe_escape(cell)}</td>\n"
                    page_html += "</tr>\n"
                page_html += "</table>\n"

            # Add images
            for img_index, img in enumerate(page.get("images", [])):
                page_html += f'<img src="{img["image"]}" alt="Image {img_index + 1} on Page {page_index}">\n'

            page_html += "</div>\n</div>\n"
            html_content += page_html

        final_html = html_template.format(content=html_content)

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(final_html)
        print(f"HTML file successfully saved at: {output_path}")

    except Exception as e:
        print(f"Unexpected error in HTML conversion: {e}")
        traceback.print_exc()

def process_pdf(pdf_path: str, output_path: str):
    try:
        print("Starting PDF extraction...")
        pages_content = extract_content(pdf_path)
        convert_to_html(pages_content, output_path)
        print("PDF to HTML conversion completed successfully!")
    except Exception as e:
        print(f"Critical error processing PDF: {e}")
        traceback.print_exc()

pdf_path="/content/output_pages/page_5.pdf"
output_path="output_v5.html"

process_pdf(pdf_path, output_path)
